---
layout: post
title: "Mockito"
date:  2019-01-21
categories: ["Testowanie"]
image: testing/mockito
github: testing/tree/master/mockito
description: "Mockito"
keywords: "testowanie, testing, testy, jednostkowe, automatyczne, lokalne, instrumentalne, dubler, zaślepka, atrapa, unit test, mock, spy, stub, junit, verify, when, thenreturn, answer, robolectric, mockito, android, programowanie, programming"
---

## Dublerzy
Testy jednostkowe rzadko kiedy dotyczą jednostki testowej wolnej od zależności innych obiektów co w konsekwencji prowadzi do definicji problemu tworzenia niezależnych testów na których rezultat nie ma wpływu żadna zależność testowanej jednostki. Wymaganą prawdziwą zależność można czasami dostarczyć ręcznie jednakże jest to kosztowne, obarczone marginesem błędu oraz często niewykonalne (szczególnie w przypadku testów instrumentalnych). Alternatywą dla tworzenia prawdziwych zależności jest dostarczanie `dublerów` (`double test`), które można sklasyfikować ze względu na przeznaczenie. Jedna z wielu definicji wyróżnia m.in. następujące obiekty: `dummy`, `fake`, `stub` i `mock`. `Dummy` jest przekazywany w celu spełnienia założeń sygnatury jednak jego metody nie są wywoływane. `Fake` posiada uproszczoną działającą implementacje spełniającą założenia interakcji. `Stub` dostarcza minimalną implementacją zależności, która pomija proces obliczeniowy i bezpośrednio zwraca zdefiniowany rezultat w taki sposób, aby test wykonał się pozytywnie. Natomiast `mock` to naiwna implementacja zależności, która bierze udział w procesie testowania i rejestruje nawiązane z nią interakcje, przeznaczona do badania zachowania. Mnogość definicji podziału dublerów oraz wynikające z tego różnice są powodem wielu niejasności, a sama terminologia jest mało istotna w procesie tworzenia zastępników. Pozwala on jednak zrozumieć co dokładnie i w jaki sposób ma zostać przetestowane. `Mockito` jest frameworkiem wspomagającym pisanie testów jednostkowych poprzez dostarczanie dublerów, które dzieli na zwyczajne `Mock` oraz częściowe `Spy`.

## Tworzenie
Obiekt zastępnika oznaczony adnotacją `@Mock` lub `@Spy` może zostać inicjalizowany na kilka sposobów, m.in. poprzez uruchomienie klasy z użyciem `@RunWith(MockitoJUnitRunner.class)`, wykorzystanie zasady `MockitoJUnit.rule()` lub manualną inicjalizację za pomocą metody `MockitoAnnotations.initMocks()`. Instancję atrapy można uzyskać statyczną metodą `mock()` lub `spy()` co pozwala na pominięcie adnotacji.

{% highlight kotlin %}
//use Mockito runner
@RunWith(MockitoJUnitRunner::class)
class InitMockRunnerTest {

    @Mock
    var obj: Data? = null

    @Test
    fun checkIsObjectInitialized() {
        assertNotNull(obj)
    }
}

//or use Mockito rule
class InitMockRuleTest {

    @Mock
    var obj: Data? = null

    @get:Rule
    var mockitoRule = MockitoJUnit.rule()

    @Test
    fun checkIsObjectInitialized() {
        assertNotNull(obj)
    }
}

//or use manual init method
class InitMockAnnotationTest {

    @Mock
    var obj: Data? = null

    @Test
    fun checkIsObjectInitialized() {
        MockitoAnnotations.initMocks(this)
        assertNotNull(obj)
    }
}

//or use static mock method
class InitMockMethodTest {

    @Test
    fun checkIsObjectInitialized() {
        val obj = mock(Data::class.java)
        assertNotNull(obj)
    }
}
{% endhighlight %}

Obiekty dublerów w Mockito mogą zostać stworzone tylko dla typów własnych. Nie można zatem dostarczyć imitacji prymitywów. Co więcej należy przestrzegać zasady, że imitacji podlegają zależności testowanej jednostki, a nie sam testowany obiekt. Adnotacja `@InjectMocks` automatycznie wstrzykuje imitacje pól oznaczonych jako `@Mock` lub `@Spy` do obiektu co jest wykorzystywane jako alternatywa dla konstruktora w sytuacji tworzenia testowanej jednostki zależnej od innych atrap.

{% highlight kotlin %}
@RunWith(MockitoJUnitRunner::class)
class InjectMockTest {

    @Mock
    var mock: Data? = null

    //constructor requires Data arg
    @InjectMocks
    var manager1: Manager? = null

    @Test
    fun checkIsManager1Initialized() {
        assertNotNull(mock)
        assertNotNull(manager1)
    }

    //equivalent
    @Test
    fun checkIsManager2Initialized() {
        var manager2 = Manager(mock)  
        assertNotNull(mock)
        assertNotNull(manager2)
    }
}
{% endhighlight %}

## Mock i Spy
Mockito wprowadza podział zastępników na zwyczajne (`Mock`) oraz częściowe (`Spy`). `Mock` nie tworzy faktycznej instancji lecz obiekt klasy szkieletowej co pozwala w całości na imitacje wykonania metod klasy bez wpływu na strukturę atrapy. `Spy` tworzy realną instancje klasy przez co wywołuje faktyczną implementację obiektu dla wszystkich zachowań dla których nie została zdefiniowana naiwna implementacja zachowując przy tym właściwości atrapy (weryfikacja i imitacja).

{% highlight kotlin %}
@RunWith(MockitoJUnitRunner::class)
class MockSpyTest {

    @Mock
    var mock: Data? = null

    @Spy
    var spy: Data? = null

    @Test
    fun checkIsObjectInitialized() {
        assertNotNull(mock)
        assertNotNull(spy)
        mock?.text = "mock"
        spy?.text = "spy"
        assertEquals("mock", mock?.text) //fails mock.text is null
        assertEquals("spy", spy?.text)
    }
}
{% endhighlight %}

## Konfiguracja
Atrapy mogą być konfigurowane w taki sposób, aby zwracały zadaną wartość w zależności od metody i argumentów. W tym celu należy zdefiniować naiwną implementację m.in. za pomocą instrukcji `when.thenReturn` czy `doReturn.when`. Różnica między nimi polega na tym, że `when.thenReturn` sprawdza typy w trakcie kompilacji, pozwala na zwracanie wielu wartości i w gruncie rzeczy wykonuje wywołaną metodę co w konsekwencji może prowadzić do rzucenia wyjątku. Natomiast `doReturn.when` wspiera obiekty opakowań (`wrapper`) oznaczone jako `@Spy` i metody nie zwracające wartości oraz eliminuje problem wielu argumentów.

{% highlight kotlin %}
@RunWith(MockitoJUnitRunner::class)
class ConfigurationTest {

    @Mock
    lateinit var mock: Data

    @Spy
    lateinit var spy: Data

    lateinit var manager: Manager

    @Before
    fun init() {
        manager = Manager(mock)
    }

    @Test
    fun checkFetchDataReturnsMockValue() {
        assertNull(manager.fetchData())
        `when`(mock.getInfo()).thenReturn("mock")
        assertNull(manager.fetchData()) //now it fails
        assertEquals("mock", manager.fetchData())
    }

    @Test
    fun checkFetchDataReturnsMultipleMockValue() {
        assertNull(manager.fetchData())
        `when`(mock.getInfo()).thenReturn("mock1", "mock2")
        assertNull(manager.fetchData()) //now it fails
        assertEquals("mock1", manager.fetchData())
        assertEquals("mock2", manager.fetchData())
        assertEquals("mock2", manager.fetchData())
    }

    @Test
    fun checkFetchDataTakesMultipleArgReturnsMockValue() {
        manager = Manager(spy)
        doReturn("spy with arg").`when`(spy).getInfo("arg1")
        doReturn("spy with arg").`when`(spy).getInfo("arg2")
        assertEquals("spy with arg", manager.fetchDataWithMessage("arg1"))
        assertEquals("spy with arg", manager.fetchDataWithMessage("arg2"))
        //not possible without reset using when.thenReturn
    }

    @Test
    fun checkGetInfoForWrappedReturnsWrapperValue() {
        val data = Data()
        val spyData = Mockito.spy(data)
        manager = Manager(spyData)
        doReturn("wrapper").`when`(spyData).getInfo()
        assertEquals("wrapper", manager.fetchData())
    }

    @Test
    fun checkFetchDataWithArgsReturnsMockValue() {
        Mockito.`when`(mock.getInfo("arg")).thenReturn("mock with arg")
        assertEquals("mock with arg", manager.fetchDataWithMessage("arg"))
        assertEquals("mock with arg", manager.fetchDataWithMessage("whatever")) //fails
        `when`(mock.getInfo(anyString())).thenReturn("mock with arg")
        assertEquals("mock with arg", manager.fetchDataWithMessage("whatever")) //now it pass
    }

    @Test(expected = IllegalArgumentException::class)
    fun checkFetchDataThrowsExceptionForSpecialCharactersArg() {
        `when`(mock.getInfo("@")).thenThrow(IllegalArgumentException())
        manager.fetchDataWithMessage("@")
    }
}
{% endhighlight %}

Dla bardziej złożonych zapytań dla których oczekiwany rezultat nie jest jawny lub zależnych od argumentów można wykorzystać instrukcję `thenAnswer` lub `doAnswer`.

{% highlight kotlin %}
@RunWith(MockitoJUnitRunner::class)
class AnswerTest {

    @Test
    fun checkFetchDataWithObjectChangedAndReturnsItsValue() {
        val spy = spy(Data::class.java)
        val manager = Manager(mock)

        assertEquals(" 0", manager.fetchData())
        assertEquals("message 0", manager.fetchDataWithMessage("message"))

        doAnswer(Answer {
            spy.number++
            spy.text = it.arguments[0] as String
            return@Answer spy.getInfo()
        }).`when`(spy).getInfo(anyString())

        assertEquals("message 1", manager.fetchDataWithMessage("message"))
        assertEquals("message 1", manager.fetchData())
    }
}
{% endhighlight %}

## Weryfikacja
Mockito przechowuje informacje na temat wszystkich wywołań metod wraz z użytymi argumentami. Dzięki temu pozwala na śledzenie działalności atrap oraz weryfikację ich wywołań za pomocą funkcji `verify()`.

{% highlight kotlin %}
@RunWith(MockitoJUnitRunner::class)
class VerifyTest {

    @Test
    fun checkHowManyTimesGetInfoCalled() {
        val mock = mock(Data::class.java)
        val manager = Manager(mock)

        verifyZeroInteractions(mock) //any methods called on the mock
        verify(mock, never()).getInfo()

        manager.fetchData()

        verify(mock, times(1)).getInfo()
        verify(mock, atLeast(1)).getInfo()
        verify(mock, atMost(3)).getInfo()
        verifyNoMoreInteractions(mock) //no others method called
    }
}
{% endhighlight %}
