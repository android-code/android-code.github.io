---
layout: post
title: "Prototyp"
date:  2018-09-10
categories: ["Wzorce projektowe"]
image: prototype
github: prototype
description: "Wzorce projektowe / kreacyjny"
keywords: "prototype, prototyp, wzorzec, wzorce projektowe, wzorzec kreacyjny, design patterns, android, java, programowanie, programming"
---

## Zastosowanie
`Prototyp` (ang. `Prototype`) (wzorzec kreacyjny) ma za zadanie utworzyć kopię macierzystego obiektu zwanego `prototypem`. Zamiast tworzyć obiekt od nowa używa on istniejącą instancje do wygenerowania jej kopii, która jest zupełnie nowym obiektem, ale o tych samych właściwościach co `prototyp`. Modyfikacja kopii nie wpływa zatem w żaden sposób na obiekt macierzysty. Użycie wzorca `Prototyp` uniezależnia system od znajomości sposobu tworzenia obiektów, a także może pozytywnie wpływać na jego wydajność. Wzorzec ten jest standardowym elementem w wielu językach programowania.

## Ograniczenia
Kopiowanie skomplikowanych obiektów z wieloma referencjami do innych obiektów może być utrudnione. W takiej sytuacji wiele klas, których instancje zawierają się w klasie obiektu macierzystego muszą implementować metodę klonowania `copy`.

## Użycie
`Prototyp` stosowany jest tam, gdzie zachodzi potrzeba tworzenia dużej ilości podobnych lub tych samych obiektów, a ich kopiowanie jest wydajniejsze niż tworzenie. Może zostać także wykorzystany wraz z innymi wzorcami kreacyjnymi jak np.: `Fabryka abstrakcyjna` czy też w procesach przywracania/przechowywania stanu systemu.

## Implementacja
Klasy dla których instancje mogą być klonowane implementują metodę `copy` w której tworzona i zwracana jest kopia bieżącego obiektu na podstawie kopi wszystkich pól obiektu. Zadanie to może zostać oddelegowane także do `konstruktora kopiującego`. Należy mieć na uwadzę, aby wszystkie klasy (których instancje zawierają się w klasie klonowanej) także implementowały metodę `copy` lub posiadały konstruktor kopiujący. W przeciwnym wypadku w klasie macierzystej należy rekurencyjnie pobrać wszystkie wartości prymitywne.

![Prototyp diagram](/assets/img/diagrams/prototype.svg){: .center-image }

Poniższy listing przedstawia implementacja wzorca `Prototyp` dla klasy `Prototype1` składającej się z prymitów - `płytka kopia` (`shallow copy`) oraz dla klasy `Prototype2` składającej się z obiektów złożonych - `głęboka kopia` (`deep copy`).

{% highlight java %}
public class Prototype1 extends Prototype {

    private double price;
    //other primitive fields

    public Prototype1() {
        super();
        this.price = 0;
    }

    public Prototype1(int price) {
        super();
        this.price = price;
    }

    public Prototype1(Prototype1 prototype) {
        super(prototype);
        if(prototype != null) {
            this.price = prototype.getPrice();
            //do the same for all fields
        }
    }

    @Override
    public Prototype copy() {
        //shallow copy
        return new Prototype1(this);
    }

    @Override
    public void action() {
        //do specific action for Prototype2
    }

    //some other methods
}

public class Prototype2 extends Prototype {

    private int value;
    private Complex complex; //has only int and boolean fields
    //other object and primitive types

    public Prototype2() {
        super();
        this.price = 0;
    }

    public Prototype2(int value, Complex complex) {
        super();
        this.value = value;
        this.complex = complex;
    }

    public Prototype2(Prototype2 prototype) {
        super(prototype);
        if(prototype != null) {
            this.value = prototype.getValue();
            //copy complex object by getting all primitive types or provide copy method/copy constructor
            this.complex = new Complex(prototype.getNumber(), prototype.getAvailability()); 
            //do the same for all fields
        }
    }

    @Override
    public Prototype copy() {
        //deep copy
        return new Prototype2(this);
    }

    @Override
    public void action() {
        //do specific action for Prototype2
    }

    //some other methods
}

public abstract class Prototype {

    //some fields
    //some common methods

    public Prototype() {
        //initialize fields  
    }

    public Prototype(Prototype prototype) {
        //copy all fields from prototype into this instance
    } 

    //in Java clone is abstract method of Object class so no need copy extra method
    public abstract Prototype copy();
    public abstract void action();
}
{% endhighlight %}

Na podstawie istniejących obiektów (`prototypów`) klient generuje ich kopie. Następnie na całej kolekcji klonów wykonuje operacje.

{% highlight java %}
//create prototype to copy
Prototype1 prototype1 = new Prototype1(10.0);
Prototype2 prototype2 = new Prototype2(5, new Details(3, true));

//copy prototypes to save time and resources
List<Prototype> clones = new ArrayList<>();
Prototype1 clone1 = prototype1.copy();
clones.add(clone1);
Prototype2 clone2 = prototype2.copy();
clones.add(clone2);
//do more clones

//do some action for every copies
for(Prototype copy : clones)
    copy.action();
{% endhighlight %}

## Przykład
TODO

{% highlight java %}
public abstract class Prototype {

    //some fields
    //some common methods

    public Prototype() {
        //initialize fields  
    }

    public Prototype(Prototype prototype) {
        //copy all fields from prototype into this instance
    } 

    //in Java clone is abstract method of Object class so no need copy extra method
    public abstract Prototype copy();
    public abstract void action();
}
{% endhighlight %}

TODO

{% highlight java %}
TODO
{% endhighlight %}

## Biblioteki
Każda klasa implementująca interfejs `Cloneable` oraz rozszerzająca metodę `copy` klasy `Object` (ze standardowego pakietu Java) jest przykładem implementacji wzorca `Prototyp` jednakże ze względu na narzucane ograniczenia takie rozwiązanie jest odradzane. Jako alternatywe podaje się `BeanUtils.cloneBean` oraz `SerializationUtils.clone`.
