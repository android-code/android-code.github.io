---
layout: post
title: "Funkcje"
date:  2018-11-26
categories: ["Kotlin"]
image: kotlin/functions
github: kotlin/blob/master/functions.kt
description: "Kotlin"
keywords: "kotlin, funkcje, functions, lambda, rekurencja, recursion, argumenty, parametry, arguments, android, programowanie, programming"
---

## Deklaracja
Funkcje w `Kotlin` deklaruje się za pomocą słowa kluczowego `fun` oraz wymaganego zwracanego typu i opcjonalnych argumentów. Jeśli funkcja przyjmuje postać wyrażania wówczas zwracany typ może być definiowany w sposób niejawny. W przypadku, gdy funkcja nie zwraca instancji żadnego konkretnego typu tylko wykonuje pewne działania wówczas tak na prawdę zwracanym typem jest `Unit` (odpowiednik `void` w `Java`). Funkcje zwracające typ `Unit` nie muszą definiować zwracanego typu w sposób jawny.

{% highlight kotlin %}
//declaration in standard way
fun tripple(): Int {
    return 3*10
}

//return Unit type
fun printText() {
    print("Hello world")
}

//declaration as expression
fun tripple() = 3*10 //note that return type declaration is not needed here

//usage
var result = tripple()
SomeClass().tripple() //if function is a member class
{% endhighlight %}

Przy użyciu słowa kluczowego infix możliwe jest deklarowanie funkcji której wywołanie następuje w notacji infiksowej (z pominięciem kropki oraz nawiasów). Funkcje zdeklarowana jako infiksowa musi być jednak funkcją właściwości klasy lub funkcją rozszerzającą oraz posiadać jeden parametr bez wartości domyślnej.

{% highlight kotlin %}
//some A class body
infix fun function(arg: Int) {} //declared as member function

//usage
var object = A()
A function 5 //infix function
A.function(5) //the same result as infix function above
{% endhighlight %}

## Zakres deklaracji
Poza standardowym sposobem deklaracji funkcji jako właściwości klasy (`member function`) deklaracja może przyjąć postać funkcji lokalnej (`funkcja w funkcji`) lub odbyć się na najwyższym poziomie struktury pliku (`top-level`) - tzn. nie musi być w ciele klasy. 

{% highlight kotlin %}
//top-level declaration
//some class declaration { ... }
fun function() {
    //do something
}

//local function declaration
fun calculate(): Int {
    fun local1(): Int {
        return 3*10
    }
    fun local2(): Int {
        return 2*10
    }
    return local1() * local2()
}
{% endhighlight %}

## Parametry
Argumenty funkcji oddziela się przecinkiem i zapisuje się w `notacji Pascala` - tzn. `nazwa: typ`. Ponadto parametry mogą przyjmować `wartość domyślną` i w przypadku braku podania ich jako argumenty funkcji przyjmą zadeklarowaną wartość. Dzięki temu redukuje się liczbę przeciążonych funkcji.

{% highlight kotlin %}
fun functionWithArgs(arg1: Int, arg2: String) {
    //some body
    print(arg2 + " " + arg1)
}

fun functionWithDefaultArgs(arg1: Int = 5, arg2: String) {
    //some body
    print(arg2 + " " + arg1)
}

//execution
functionWithArgs(10, "text") //text 10
functionWithDefaultArgs(10, "text") //text 10
functionWithDefaultArgs("text") //text 5
{% endhighlight %}

Jeśli funkcja z argumentami o wartościach domyślnych jest nadpisywana w klasie pochodnej wówczas wartość domyślna jest zawsze brana z funkcji klasy bazowej i niemożliwe jest jej nadpisanie.

{% highlight kotlin %}
//some A class
fun function(arg1: Int = 5, arg2: String) {}

//other B class extending A class
override fun function(arg1: Int = 10, arg2: String) {} //compiler error
override fun function(arg1: Int, arg2: String) {} //correct overriding
{% endhighlight %}

Funkcje mogą przyjmować typy generyczne poprzez zastosowanie wyrażenia `<Type>` przed nazwą funkcji.

{% highlight kotlin %}
//declaration
fun <T> functionGenericType(item: T): List<T> { 
    var list: List<T> = listOf(item, item, item)
    return list
}

//execution
var someList = functionGenericType<Int>(10)
someList = functionGenericType(10) //type can be missing if known from context
{% endhighlight %}

## Parametry nazwane
Argument nazwany (`named argument`) pozwala na wywołanie funkcji wraz z nazwami argumentów co umożliwia wywołanie funkcji z parametrami domyślnymi (gdy te w deklaracji poprzedzają argumenty bez wartości domyślnej) oraz zwiększa czytelność wywołania funkcji o wielu argumentach.

{% highlight kotlin %}
fun function(arg1: Int = 10, arg2: String) {}
function("text") //compile error
function(arg2 = "text") //correct executing using named arg

fun functionWithManyArgs(id: Int, number: Int, name: String, citizen: Boolean, adult: Boolean)
functionWithManyArgs(100, 1, "Jack", true, false) //proper but not easy to understand
functionWithManyArgs(id=100, number=1, name="Jack", citizen=true, adult=false) //more cleaner way
{% endhighlight %}

Jednakże jeśli funkcja jest wywoływana z użyciem `parametrów nazwanych oraz pozycyjnych` wówczas wszystkie argumenty pozycyjne muszą być podane przed pierwszym wystąpieniem argumentu nazwanego.

fun function(arg1: Int, arg2: String) {}
function(10, arg2="text") //correct
function(arg2="text", 10) //compile error

Jeśli `funkcja lambda` jest ostatnim parametrem funkcji, a poprzedzają ją parametry z wartościami domyślnymi wówczas wywołanie funkcji z argumentami domyślnymi nie wymaga nazwania ostatniego argumentu.

{% highlight kotlin %}
fun function(arg1: Int = 10, arg2: Int = 5, lambda: () -> Unit) {}
function(3) { print("lambda action") } //arg1=3, arg2=5
function() { print("lambda action") } //arg1=10, arg2=5
{% endhighlight %}

## Zmienna ilość argumentów
W Kotlin za pomocą słowa kluczowego `vararg` funkcje mogą przyjmować zmienną ilość argumentów w postaci listy argumentów. Taki argument (o zmiennej ilości elementów) może być tylko jeden i przeważnie jest ostatnim parametrem funkcji. Jeśli argument `vararg` nie jest ostatnim w deklaracji funkcji wówczas argumenty następujące po nim muszą być wywołane jako nazwane.

{% highlight kotlin %}
fun function(vararg args: Int, text: String) {} //vararg should be the last one arg
function(1,2,3, "text") //compile error
function(1,2,3, text="text") //correct execution with named arg

//vararg could be passed as list with * modifier
var array = arrayOf(1,2,3)
function(*array, text="text")
{% endhighlight %}

## Funkcje wyższego rzędu
Funkcje w Kotlin mogą być przechowywane w zmiennych i strukturach danych oraz przekazywane jako argumenty do innych funkcji czy też zwracane jako wynik innej funkcji (`first-class function`). Przekazywanie funkcji jako argumentu może odbywać się poprzez wyrażenie `lambda`, referencję czy funkcję anonimową.

{% highlight kotlin %}
//take function as argument
fun functionWithFunArg(arg: Int = 10, lambda: (a: Int) -> Int) {
    //do some work and use lambda function
    lambda(arg)
}

//execute function with function as argument
var lambdaArg = { a: Int -> a*a }
functionWithFunArg(3, lambdaArg) 
functionWithFunArg(3) { a: Int -> a*a } 

//return function from function
fun functionWithFunReturn(arg: Int) : (a: Int) -> String {
	return { a -> "value=" + (arg*a) }
}

//execute function with function type returned
var lambdaReturn = functionWithFunReturn(10)
lambdaReturn(2)
{% endhighlight %}

Funkcje wyższego rzędu są przechowywane w pamięci jako obiekty co może wiązać się z przepełnieniem pamięci (np. gdy funkcja jest wywoływana w pętli - za każdym razem tworzy się nowy obiekt). Aby temu zapobieć można zdeklarować funkcję jako `inline`, jednakże jej użycie spowoduje zwiększenie kodu wynikowego `bytecode`. Funkcje oznaczone jako inline w celu otrzymania dostępu do prywatnych pól i metod klasy wymagają na właściwościach klasy modyfikatora `internal` oraz adnotacji `@PublishedApi`. Co więcej funkcje inline pozwalają wyrażeniu lambda na wyjście z funkcji wywoławczej poprzez użycie `return`.

{% highlight kotlin %}
@PublishedApi
internal var internalMember = "internal"
private var privateMember = "private"

inline functionInline(arg: Int = 10, lambda: (a: Int) -> Unit) {
    privateMember.toString() //compile error - not allowed
    internalMember.toString() //it's okay
    lambda(arg)
    print("This is unreachable") //because of return statement in executing
}

//execution
functionInline {
    //do something
    return //it is possible because function is inline
}
{% endhighlight %}

## Rekurencja ogonowa
Kotlin czerpiąc z programowanie funkcyjnego udostępnia mechanizm rekurencji ogonowej (`tail recursion`), dzięki któremu niektóre algorytmy, które mogłyby zostać napisane przy użyciu pętli są zastępowane funkcjami rekurencyjnymi bez ponoszenia ryzyka przepełnienia stosu. Aby zadeklarować funkcję rekurencji ogonowej należy użyć słowa kluczowego `tailrec`. Wywołana funkcja rekurencji ogonowej musi być jednak ostatnią czynnością w bloku kodu i nie może występować w bloku `try-catch`.

{% highlight kotlin %}
tailrec fun fibonacci(n: Int, a: Long, b: Long): Long {
    return if (n == 0) b else fibonacci(n-1, a+b, a)
}

//instead of loop
fun fibonacciLoop(n: Int, a: Long, b: Long): Long {
    var counter = 1
    while(counter <= n) {
        var sum=a+b
        a=b
        b=sum
        counter++
    }
}
{% endhighlight %}
